<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MCP Task Manager</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        .header {
            text-align: center;
            margin-bottom: 2rem;
            color: white;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .main-layout {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 2rem;
        }

        .sidebar {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            height: fit-content;
        }

        .main-content {
            background: white;
            border-radius: 12px;
            padding: 2rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .task-form {
            margin-bottom: 2rem;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: #2c3e50;
        }

        .form-control {
            width: 100%;
            padding: 0.8rem;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }

        .form-control:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            padding: 0.8rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-warning {
            background: #ffc107;
            color: #212529;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn:hover {
            opacity: 0.9;
            transform: translateY(-2px);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
            border: 2px solid #e9ecef;
        }

        .stat-number {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 0.25rem;
        }

        .stat-total { color: #6c757d; }
        .stat-pending { color: #ffc107; }
        .stat-completed { color: #28a745; }
        .stat-overdue { color: #dc3545; }

        .filter-controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        .task-list {
            max-height: 600px;
            overflow-y: auto;
        }

        .task-item {
            border: 2px solid #e9ecef;
            border-radius: 8px;
            margin-bottom: 1rem;
            padding: 1.5rem;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .task-item:hover {
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .task-item.completed {
            background: #d4edda;
            border-color: #28a745;
        }

        .task-item.overdue {
            background: #f8d7da;
            border-color: #dc3545;
        }

        .task-header {
            display: flex;
            justify-content: between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .task-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 0.5rem;
        }

        .task-description {
            color: #6c757d;
            margin-bottom: 1rem;
            line-height: 1.5;
        }

        .task-meta {
            display: flex;
            gap: 1rem;
            font-size: 0.9rem;
            color: #6c757d;
            margin-bottom: 1rem;
        }

        .task-actions {
            display: flex;
            gap: 0.5rem;
        }

        .task-actions .btn {
            padding: 0.4rem 0.8rem;
            font-size: 0.9rem;
        }

        .priority-high { border-left: 4px solid #dc3545; }
        .priority-medium { border-left: 4px solid #ffc107; }
        .priority-low { border-left: 4px solid #28a745; }

        .sidebar-section {
            margin-bottom: 2rem;
        }

        .sidebar-section h3 {
            margin-bottom: 1rem;
            color: #2c3e50;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 0.5rem;
        }

        .quick-actions {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .export-import {
            display: flex;
            gap: 0.5rem;
        }

        .memory-info {
            background: #e3f2fd;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
        }

        .storage-info {
            background: #f3e5f5;
            padding: 1rem;
            border-radius: 8px;
            font-size: 0.9rem;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
        }

        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 12px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6c757d;
        }

        @media (max-width: 768px) {
            .main-layout {
                grid-template-columns: 1fr;
            }

            .filter-controls {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìã MCP Task Manager</h1>
            <p>Smart task management with persistent storage and intelligent features</p>
        </div>

        <div class="main-layout">
            <div class="sidebar">
                <div class="sidebar-section">
                    <h3>üìä Statistics</h3>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-number stat-total" id="totalTasks">0</div>
                            <div>Total</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number stat-pending" id="pendingTasks">0</div>
                            <div>Pending</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number stat-completed" id="completedTasks">0</div>
                            <div>Done</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number stat-overdue" id="overdueTasks">0</div>
                            <div>Overdue</div>
                        </div>
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3>‚ö° Quick Actions</h3>
                    <div class="quick-actions">
                        <button class="btn btn-primary" onclick="showAddTaskModal()">‚ûï Add Task</button>
                        <button class="btn btn-success" onclick="syncData()">üîÑ Sync Data</button>
                        <button class="btn btn-warning" onclick="updateReminders()">‚è∞ Update Reminders</button>
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3>üíæ Data Management</h3>
                    <div class="export-import">
                        <button class="btn btn-secondary" onclick="exportTasks()">üì§ Export</button>
                        <button class="btn btn-secondary" onclick="document.getElementById('importFile').click()">üì• Import</button>
                    </div>
                    <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importTasks(event)">
                </div>

                <div class="memory-info">
                    <strong>üß† Memory Server</strong><br>
                    <span id="memoryStatus">Connected</span><br>
                    <small>Storing user preferences and task history</small>
                </div>

                <div class="storage-info">
                    <strong>üóÑÔ∏è SQLite Storage</strong><br>
                    <span id="storageStatus">Active</span><br>
                    <small>Persistent task database</small>
                </div>
            </div>

            <div class="main-content">
                <div class="filter-controls">
                    <select class="form-control" id="statusFilter" onchange="filterTasks()">
                        <option value="all">All Tasks</option>
                        <option value="pending">Pending</option>
                        <option value="completed">Completed</option>
                        <option value="overdue">Overdue</option>
                    </select>
                    <select class="form-control" id="priorityFilter" onchange="filterTasks()">
                        <option value="all">All Priorities</option>
                        <option value="high">High Priority</option>
                        <option value="medium">Medium Priority</option>
                        <option value="low">Low Priority</option>
                    </select>
                    <input type="text" class="form-control" id="searchInput" placeholder="Search tasks..." onkeyup="filterTasks()">
                </div>

                <div class="task-list" id="taskList">
                    <!-- Tasks will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Add/Edit Task Modal -->
    <div class="modal" id="taskModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modalTitle">Add New Task</h3>
                <button class="close-btn" onclick="hideTaskModal()">&times;</button>
            </div>
            <form id="taskForm" onsubmit="saveTask(event)">
                <div class="form-group">
                    <label for="taskTitle">Title</label>
                    <input type="text" class="form-control" id="taskTitle" required>
                </div>
                <div class="form-group">
                    <label for="taskDescription">Description</label>
                    <textarea class="form-control" id="taskDescription" rows="3"></textarea>
                </div>
                <div class="form-group">
                    <label for="taskPriority">Priority</label>
                    <select class="form-control" id="taskPriority">
                        <option value="low">Low</option>
                        <option value="medium" selected>Medium</option>
                        <option value="high">High</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="taskDueDate">Due Date</label>
                    <input type="datetime-local" class="form-control" id="taskDueDate">
                </div>
                <div class="form-group">
                    <label for="taskCategory">Category</label>
                    <input type="text" class="form-control" id="taskCategory" placeholder="Work, Personal, etc.">
                </div>
                <div style="display: flex; gap: 1rem; justify-content: flex-end;">
                    <button type="button" class="btn btn-secondary" onclick="hideTaskModal()">Cancel</button>
                    <button type="submit" class="btn btn-primary">Save Task</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        let tasks = [];
        let editingTaskId = null;

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            loadTasks();
            updateStats();
            initializeMemoryServer();
            scheduleReminderUpdates();
        });

        function initializeMemoryServer() {
            // Simulate memory server connection
            document.getElementById('memoryStatus').textContent = 'Connected';

            // Store user preferences in memory
            const preferences = {
                defaultPriority: 'medium',
                reminderTime: 30, // minutes before due date
                autoSync: true,
                theme: 'default'
            };

            // This would normally use the MCP memory server
            localStorage.setItem('userPreferences', JSON.stringify(preferences));
        }

        function loadTasks() {
            // Simulate loading from SQLite via MCP server
            const savedTasks = localStorage.getItem('tasks');
            if (savedTasks) {
                tasks = JSON.parse(savedTasks);
            } else {
                // Initialize with sample data
                tasks = [
                    {
                        id: Date.now() + 1,
                        title: 'Set up MCP servers',
                        description: 'Configure all MCP servers for the task management application',
                        priority: 'high',
                        dueDate: new Date(Date.now() + 86400000).toISOString(), // Tomorrow
                        category: 'Development',
                        status: 'completed',
                        createdAt: new Date().toISOString(),
                        completedAt: new Date().toISOString()
                    },
                    {
                        id: Date.now() + 2,
                        title: 'Test memory server integration',
                        description: 'Verify that user preferences are stored correctly in the memory server',
                        priority: 'medium',
                        dueDate: new Date(Date.now() + 172800000).toISOString(), // 2 days
                        category: 'Testing',
                        status: 'pending',
                        createdAt: new Date().toISOString()
                    },
                    {
                        id: Date.now() + 3,
                        title: 'Implement time server features',
                        description: 'Add timezone support and due date calculations using the time server',
                        priority: 'low',
                        dueDate: new Date(Date.now() - 86400000).toISOString(), // Yesterday (overdue)
                        category: 'Development',
                        status: 'pending',
                        createdAt: new Date().toISOString()
                    }
                ];
                saveTasks();
            }
            renderTasks();
        }

        function saveTasks() {
            // This would normally use the SQLite MCP server
            localStorage.setItem('tasks', JSON.stringify(tasks));
            updateStats();
        }

        function renderTasks() {
            const taskList = document.getElementById('taskList');
            const statusFilter = document.getElementById('statusFilter').value;
            const priorityFilter = document.getElementById('priorityFilter').value;
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();

            let filteredTasks = tasks.filter(task => {
                const matchesStatus = statusFilter === 'all' || getTaskStatus(task) === statusFilter;
                const matchesPriority = priorityFilter === 'all' || task.priority === priorityFilter;
                const matchesSearch = task.title.toLowerCase().includes(searchTerm) ||
                                    task.description.toLowerCase().includes(searchTerm) ||
                                    task.category.toLowerCase().includes(searchTerm);

                return matchesStatus && matchesPriority && matchesSearch;
            });

            // Sort by priority and due date
            filteredTasks.sort((a, b) => {
                const priorityOrder = { high: 3, medium: 2, low: 1 };
                if (priorityOrder[a.priority] !== priorityOrder[b.priority]) {
                    return priorityOrder[b.priority] - priorityOrder[a.priority];
                }
                return new Date(a.dueDate) - new Date(b.dueDate);
            });

            taskList.innerHTML = '';

            if (filteredTasks.length === 0) {
                taskList.innerHTML = '<div style="text-align: center; color: #6c757d; padding: 2rem;">No tasks found</div>';
                return;
            }

            filteredTasks.forEach(task => {
                const taskElement = createTaskElement(task);
                taskList.appendChild(taskElement);
            });
        }

        function createTaskElement(task) {
            const div = document.createElement('div');
            const status = getTaskStatus(task);

            div.className = `task-item priority-${task.priority} ${status}`;
            div.innerHTML = `
                <div class="task-title">${task.title}</div>
                <div class="task-description">${task.description}</div>
                <div class="task-meta">
                    <span>üìÖ ${formatDate(task.dueDate)}</span>
                    <span>üè∑Ô∏è ${task.category}</span>
                    <span>‚ö° ${task.priority.charAt(0).toUpperCase() + task.priority.slice(1)}</span>
                    <span>üìä ${status.charAt(0).toUpperCase() + status.slice(1)}</span>
                </div>
                <div class="task-actions">
                    ${task.status === 'completed' ?
                        `<button class="btn btn-warning" onclick="toggleTaskStatus(${task.id})">‚Ü©Ô∏è Reopen</button>` :
                        `<button class="btn btn-success" onclick="toggleTaskStatus(${task.id})">‚úÖ Complete</button>`
                    }
                    <button class="btn btn-primary" onclick="editTask(${task.id})">‚úèÔ∏è Edit</button>
                    <button class="btn btn-danger" onclick="deleteTask(${task.id})">üóëÔ∏è Delete</button>
                </div>
            `;

            return div;
        }

        function getTaskStatus(task) {
            if (task.status === 'completed') return 'completed';
            if (new Date(task.dueDate) < new Date()) return 'overdue';
            return 'pending';
        }

        function formatDate(dateString) {
            const date = new Date(dateString);
            return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        }

        function updateStats() {
            const total = tasks.length;
            const completed = tasks.filter(t => t.status === 'completed').length;
            const pending = tasks.filter(t => getTaskStatus(t) === 'pending').length;
            const overdue = tasks.filter(t => getTaskStatus(t) === 'overdue').length;

            document.getElementById('totalTasks').textContent = total;
            document.getElementById('completedTasks').textContent = completed;
            document.getElementById('pendingTasks').textContent = pending;
            document.getElementById('overdueTasks').textContent = overdue;
        }

        function showAddTaskModal() {
            editingTaskId = null;
            document.getElementById('modalTitle').textContent = 'Add New Task';
            document.getElementById('taskForm').reset();
            document.getElementById('taskModal').style.display = 'block';
        }

        function hideTaskModal() {
            document.getElementById('taskModal').style.display = 'none';
        }

        function saveTask(event) {
            event.preventDefault();

            const title = document.getElementById('taskTitle').value;
            const description = document.getElementById('taskDescription').value;
            const priority = document.getElementById('taskPriority').value;
            const dueDate = document.getElementById('taskDueDate').value;
            const category = document.getElementById('taskCategory').value || 'General';

            if (editingTaskId) {
                // Edit existing task
                const taskIndex = tasks.findIndex(t => t.id === editingTaskId);
                if (taskIndex !== -1) {
                    tasks[taskIndex] = {
                        ...tasks[taskIndex],
                        title,
                        description,
                        priority,
                        dueDate,
                        category,
                        updatedAt: new Date().toISOString()
                    };
                }
            } else {
                // Add new task
                const newTask = {
                    id: Date.now(),
                    title,
                    description,
                    priority,
                    dueDate,
                    category,
                    status: 'pending',
                    createdAt: new Date().toISOString()
                };
                tasks.push(newTask);
            }

            saveTasks();
            renderTasks();
            hideTaskModal();
        }

        function editTask(taskId) {
            const task = tasks.find(t => t.id === taskId);
            if (!task) return;

            editingTaskId = taskId;
            document.getElementById('modalTitle').textContent = 'Edit Task';
            document.getElementById('taskTitle').value = task.title;
            document.getElementById('taskDescription').value = task.description;
            document.getElementById('taskPriority').value = task.priority;
            document.getElementById('taskDueDate').value = task.dueDate.slice(0, 16); // Format for datetime-local
            document.getElementById('taskCategory').value = task.category;
            document.getElementById('taskModal').style.display = 'block';
        }

        function deleteTask(taskId) {
            if (confirm('Are you sure you want to delete this task?')) {
                tasks = tasks.filter(t => t.id !== taskId);
                saveTasks();
                renderTasks();
            }
        }

        function toggleTaskStatus(taskId) {
            const task = tasks.find(t => t.id === taskId);
            if (!task) return;

            if (task.status === 'completed') {
                task.status = 'pending';
                delete task.completedAt;
            } else {
                task.status = 'completed';
                task.completedAt = new Date().toISOString();
            }

            saveTasks();
            renderTasks();
        }

        function filterTasks() {
            renderTasks();
        }

        function syncData() {
            // Simulate syncing with memory and SQLite servers
            const syncBtn = event.target;
            syncBtn.textContent = 'üîÑ Syncing...';
            syncBtn.disabled = true;

            setTimeout(() => {
                saveTasks();
                syncBtn.textContent = 'üîÑ Sync Data';
                syncBtn.disabled = false;
                alert('Data synchronized successfully!');
            }, 1500);
        }

        function updateReminders() {
            // Simulate using the time server to update reminders
            const reminderBtn = event.target;
            reminderBtn.textContent = '‚è∞ Updating...';
            reminderBtn.disabled = true;

            setTimeout(() => {
                const upcomingTasks = tasks.filter(task => {
                    if (task.status === 'completed') return false;
                    const dueDate = new Date(task.dueDate);
                    const now = new Date();
                    const timeDiff = dueDate - now;
                    return timeDiff > 0 && timeDiff < 24 * 60 * 60 * 1000; // Due in next 24 hours
                });

                reminderBtn.textContent = '‚è∞ Update Reminders';
                reminderBtn.disabled = false;

                if (upcomingTasks.length > 0) {
                    alert(`Reminder: You have ${upcomingTasks.length} task(s) due in the next 24 hours!`);
                } else {
                    alert('No upcoming tasks in the next 24 hours.');
                }
            }, 1000);
        }

        function exportTasks() {
            const exportData = {
                tasks,
                exportDate: new Date().toISOString(),
                version: '1.0'
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `tasks-export-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function importTasks(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importData = JSON.parse(e.target.result);
                    if (importData.tasks && Array.isArray(importData.tasks)) {
                        if (confirm('This will replace all existing tasks. Continue?')) {
                            tasks = importData.tasks;
                            saveTasks();
                            renderTasks();
                            alert('Tasks imported successfully!');
                        }
                    } else {
                        alert('Invalid file format!');
                    }
                } catch (error) {
                    alert('Error reading file: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        function scheduleReminderUpdates() {
            // Simulate using time server for periodic reminder checks
            setInterval(() => {
                const overdueTasks = tasks.filter(task =>
                    task.status !== 'completed' && new Date(task.dueDate) < new Date()
                );

                if (overdueTasks.length > 0) {
                    document.title = `üìã Task Manager (${overdueTasks.length} overdue)`;
                } else {
                    document.title = 'üìã MCP Task Manager';
                }
            }, 60000); // Check every minute
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('taskModal');
            if (event.target === modal) {
                hideTaskModal();
            }
        };
    </script>
</body>
</html>
